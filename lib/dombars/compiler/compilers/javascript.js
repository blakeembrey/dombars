var createFrame    = require('../../handlebars').createFrame;
var CommonCompiler = require('./common').prototype;

/**
 * Extends Handlebars JavaScript compiler to add DOM specific rules.
 */
var Compiler = module.exports = function () {};
Compiler.prototype = createFrame(CommonCompiler);
Compiler.prototype.compiler     = Compiler;
Compiler.prototype.attrCompiler = require('./attributes');

/**
 * Compiles the environment object generated by the base compiler.
 *
 * @param  {Object}            environment
 * @return {(Function|String)}
 */
Compiler.prototype.compile = function () {
  this.elementSlot = 0;

  return CommonCompiler.compile.apply(this, arguments);
};

/**
 * Compile any child program nodes. E.g. Block helpers.
 *
 * @param {Object} environment
 * @param {Object} options
 */
Compiler.prototype.compileChildren = function(environment, options) {
  var children = environment.children;
  var Compiler, child, program, index;

  for (var i = 0, l = children.length; i < l; i++) {
    child    = children[i];
    index    = this.matchExistingProgram(child);
    Compiler = this.compiler;

    if (child.attribute) {
      Compiler = this.attrCompiler;
    }

    if (index == null) {
      this.context.programs.push('');
      child.index = index = this.context.programs.length;
      child.name  = 'program' + index;
      program = new Compiler().compile(child, options, this.context);
      this.context.programs[index]     = program;
      this.context.environments[index] = child;
    } else {
      child.index = index;
      child.name  = 'program' + index;
    }
  }
};

/**
 * Push an element onto the stack and return it.
 *
 * @return {String}
 */
Compiler.prototype.pushElement = function () {
  return 'element' + (++this.elementSlot);
};

/**
 * Pop the last element off the stack and return it.
 *
 * @return {String}
 */
Compiler.prototype.popElement = function () {
  return 'element' + (this.elementSlot--);
};

/**
 * Returns the element at the end of the stack.
 *
 * @return {String}
 */
Compiler.prototype.topElement = function () {
  return 'element' + this.elementSlot;
};

/**
 * Append some content to the buffer (a document fragment).
 *
 * @param  {String} string
 * @return {String}
 */
Compiler.prototype.appendToBuffer = function (string) {
  if (this.environment.isSimple) {
    return 'return ' + string + ';';
  }

  this.context.aliases.append = 'this.appendChild';

  return 'append(buffer, ' + string + ');';
};

/**
 * Initialize the base value of the buffer, in this case a document fragment.
 *
 * @return {String}
 */
Compiler.prototype.initializeBuffer = function () {
  return 'document.createDocumentFragment()';
};

/**
 * Merges the source into a stringified output.
 *
 * @return {String}
 */
Compiler.prototype.mergeSource = function () {
  return this.source.join('\n');
};

/**
 * Append a variable to the stack. Adds some additional logic to transform the
 * text into a DOM node before we attempt to append it to the buffer.
 */
Compiler.prototype.append = function () {
  this.flushInline();
  var local = this.popStack();

  this.context.aliases.domify      = 'this.domifyExpression';
  this.context.aliases.subscribe   = 'this.subscribe';
  this.context.aliases.replaceNode = 'this.replaceNode';

  var stack = this.pushStack('domify(' + local + ')');
  this.source.push('subscribe(function (value) {');
  this.source.push(stack + ' = replaceNode(domify(value), ' + stack + ');');
  this.source.push('}, true);');
  this.source.push(this.appendToBuffer(stack));
};

/**
 * Append a text node to the buffer.
 *
 * @param {String} content
 */
Compiler.prototype.appendContent = function (content) {
  var string = 'document.createTextNode(' + this.quotedString(content) + ')';
  this.source.push(this.appendToBuffer(string));
};

/**
 * Append an escaped Handlebars expression to the source.
 */
Compiler.prototype.appendEscaped = function () {
  var inline = this.isInline();
  var stack  = this.topStack();

  this.context.aliases.textify     = 'this.textifyExpression';
  this.context.aliases.subscribe   = 'this.subscribe';
  this.context.aliases.replaceNode = 'this.replaceNode';

  var text  = this.pushStack(
    'function () { return textify(' +
      (inline ? this.popStack() : stack) +
    '); }'
  );
  var value = this.pushStack(text + '()');

  this.source.push('subscribe(function (value) {' +
    (inline ? '' : stack + ' = value;') +
    value + ' = replaceNode(' + text + '(), ' + value + ');' +
  '}, true);');

  this.source.push(this.appendToBuffer(value));
};

/**
 * Append an element node to the source.
 */
Compiler.prototype.appendElement = function () {
  this.source.push(this.appendToBuffer(this.popStack()));
};

/**
 * Create a DOM comment node ready for appending to the current buffer.
 */
Compiler.prototype.invokeComment = function () {
  var depth  = 'depth' + this.lastContext;
  var invoke = this.topStack() + '(' + depth + ')';

  this.context.aliases.subscribe   = 'this.subscribe';
  this.context.aliases.replaceNode = 'this.replaceNode';

  var current = this.pushStack('document.createComment(' + invoke + ')');

  this.source.push('subscribe(function () {' +
    current + '.textContent = ' + invoke + ';' +
  '});');
};

/**
 * Create a DOM element node ready for appending to the current buffer.
 */
Compiler.prototype.invokeElement = function () {
  var element = this.pushElement();
  var current = this.popStack();
  var depth   = 'depth' + this.lastContext;
  var create  = 'createElement(' + current + '(' + depth + '))';

  this.context.aliases.subscribe          = 'this.subscribe';
  this.context.aliases.createElement      = 'this.createElement';
  this.context.aliases.copyAndReplaceNode = 'this.copyAndReplaceNode';

  this.push(element);
  this.register(element, create);

  this.source.push('subscribe(function () {' +
    element + ' = copyAndReplaceNode(' + create + ', ' + element + ');' +
  '});');
};

/**
 * Append an attribute node to the current element.
 */
Compiler.prototype.invokeAttribute = function () {
  var depth   = 'depth' + this.lastContext;
  var element = this.topElement();
  var value   = this.popStack();
  var name    = this.popStack();

  this.context.aliases.self       = 'this';
  this.context.aliases.setAttr    = 'this.setAttribute';
  this.context.aliases.subscribe  = 'this.subscribe';
  this.context.aliases.removeAttr = 'this.removeAttribute';

  var execName  = 'nameProgram(' + depth + ')';
  var execValue = 'valueProgram(' + depth + ')';

  this.source.push('(function (nameProgram, valueProgram) {');

  this.source.push('var name = ' + execName  + ';');
  this.source.push(
    'subscribe(function () {' +
      'removeAttr(' + element + ', name);' +
      'setAttr(' + element + ', name = ' + execName + ', value);' +
    '});'
  );

  this.source.push('var value = ' + execValue + ';');
  this.source.push(
    'subscribe(function () {' +
      'setAttr(' + element + ', name, value = ' + execValue + ');' +
    '});'
  );

  this.source.push('setAttr(' + element + ', name, value);');

  this.source.push('})(' + name + ',' + value + ');');
};

/**
 * Invoke an arbitrary program and append to the current element.
 */
Compiler.prototype.invokeContent = function () {
  var element = this.topElement();
  var depth   = 'depth' + this.lastContext;

  this.context.aliases.append = 'this.appendChild';

  this.register('child', this.popStack() + '(' + depth + ')');

  // Check that we have a child node before we attempt to append to the DOM.
  // This is here for catching comment only program nodes which output
  // `undefined`.
  this.source.push(
    'if (child != null) { append(' + element + ', child); }'
  );
};

Compiler.prototype.programExpression = function (guid) {
  this.context.aliases.self = 'this';

  if (guid == null) {
    return 'self.noop';
  }

  var child         = this.environment.children[guid];
  var depths        = child.depths.list;
  var programParams = [child.index, child.name, 'data'];

  for (var i = 0, l = depths.length; i < l; i++) {
    var depth = depths[i] + this.environment.depths.list.length;

    programParams.push('depth' + (depth - 1));
  }

  var params = programParams.join(', ');

  if (depths.length === 0) {
    return 'self.program(' + params + ')';
  }

  return 'self.programWithDepth(' + params + ')';
};
