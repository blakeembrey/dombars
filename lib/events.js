var Utils = require('./utils');

/**
 * Events object mixin. Created to keep the runtime size down since including
 * the node event emitter is a huge dependency.
 *
 * @type {Object}
 */
var Events = module.exports = {};

/**
 * Listen to any events triggered.
 *
 * @param  {String}   name
 * @param  {Function} fn
 * @param  {Object}   context
 * @return {Events}
 */
Events.on = function (name, fn, context) {
  this._events || (this._events = {});
  var events = this._events[name] || (this._events[name] = []);
  events.push({ fn: fn, context: context });
};

/**
 * Listen to any events triggered once.
 *
 * @param  {String}   name
 * @param  {Function} fn
 * @param  {Object}   context
 * @return {Events}
 */
Events.once = function (name, fn, context) {
  var that = this;

  // Using the `on` functionality we can create a `once` function.
  this.on(name, function self () {
    that.off(name, self);
    fn.apply(this, arguments);
  }, context);
};

/**
 * Remove an event listener.
 *
 * @param  {String}   name
 * @param  {Function} fn
 * @param  {Object}   context
 * @return {Events}
 */
Events.off = function (name, fn, context) {
  // Delete all event listeners when no arguments are passed in.
  if (arguments.length === 0) {
    return delete this._events;
  }

  // Delete an entire event namespace when only the name is passed in.
  if (arguments.length === 1) {
    return delete this._events[name];
  }

  // If the namespace does not exist, return early.
  if (!this._events || !this._events[name]) {
    return;
  }

  // Iterate over the event namespace and delete listeners where the function
  // identities and optional context matches.
  var events = this._events[name];
  for (var i = 0; i < events.length; i++) {
    if (events[i].fn === fn) {
      if (arguments.length === 2 || events[i].context === context) {
        events.splice(i, 1);
        i--;
      }
    }
  }

  // Remove empty namespaces.
  if (!events.length) {
    delete this._events[name];
  }
};

/**
 * Emit an event.
 *
 * @param  {String} name
 * @param  {*}      ...
 * @return {Events}
 */
Events.emit = Utils.variadic(function (name, args) {
  if (!this._events || !this._events[name]) { return; }

  // Create a replicated array of the event namespace so unsubscribing within
  // calls (E.g. `off`) doesn't break the iteration.
  var events = this._events[name].slice();

  for (var i = 0; i < events.length; i++) {
    events[i].fn.apply(events[i].context, args);
  }
});
